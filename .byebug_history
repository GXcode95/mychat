return false
owner?
self.owner?
role
self
c
users_room_pending.role
users_room.role
c
users_room.role
c
message.room.owner?(user)
c
message.room.role_of(user)
message.room.role_of(message.author)
message.room
message.rooom
c
can?(:create, UsersRoom)
c
exit
self
request
params
users_room.reload
users_room;reload
users_room
c
response.body
c
  response.should redirect_to(rooms_path)
  response.should redirect_to(room_path)
response
response.body
c
request.format
c
response.body
response/body
c
response.body
c
room_params
c
params
room_params
c
@room
@room.valid?
c
response.body
response.methods
c
@user = User.find(params[:user_id])
c
rooms_url
rooms_path
c
request
c
request
response
post('/rooms')
c
response
reponse
post('/rooms')
c
response.status
 post '/rooms', params: { room: {} }
response
post('/rooms')
post
c
room
c
room.size
room
c
exit
c
users.pluck(:id)
userspluck(:id)
users.ids
aa.first.users.ids
aa = private_rooms.
      select('rooms.*, COUNT(users_rooms.user_id)').
      joins(:users_rooms).
      where(users_rooms: { user_id: users.pluck(:id) }).
      group('rooms.id')
private_rooms.
      select('rooms.*, COUNT(users_rooms.user_id)').
      joins(:users_rooms).
      where(users_rooms: { user_id: users.pluck(:id) }).
      group('rooms.id')
c
room.ids
c
users.first.users_rooms.first.room.id
users.first.users_rooms.ids
users.first
c
room
c
user2.id
user1.id
room.first.users_rooms.pluck(:user_id)
room.first.users_rooms
room
user2.users_rooms
user2.users_room
user1.users_rooms
exit
public_room.users_rooms
public_room.users
public_room
public_room.users.first
users = [private_room.users.first, public_room.users.first]
users = private_room.users
Room.select('rooms.*, COUNT(users_rooms.user_id)').joins(:users_rooms).where(users_rooms: { user_id: users.pluck(:id) })
Room.select('rooms.*, COUNT(users_rooms.user_id)').joins(:users_rooms)
Room.select('rooms.*, COUNT(users_rooms.user_id)').joins(:users_rooms).
c
private_room.users.ids
Room.find(1200).users_rooms.first.id
Room.find(1200).users_rooms.first
Room.find(1200).users_rooms
Room.find(1200)
Room.private_rooms.ids
room.ids
c
room
c
x
room
c
users.first
users
users.size
Room.private_rooms.
      select('rooms.*, COUNT(users_rooms.user_id)').
      joins(:users_rooms).
      where(users_rooms: { user_id: users }).
      group('rooms.id').
      having('COUNT(users_rooms.user_id) = ?', users.size)
private_rooms.
      select('rooms.*, COUNT(users_rooms.user_id)').
      joins(:users_rooms).
      where(users_rooms: { user_id: users }).
      group('rooms.id').
      having('COUNT(users_rooms.user_id) = ?', users.size)
c
room
c
users
c
Room.private_rooms.
      select('rooms.*, COUNT(users_rooms.user_id)').
      joins(:users_rooms).
      where(users_rooms: { user_id: users }).
      group('rooms.id').
      having('COUNT(users_rooms.user_id) = ?', users.size)
Room.by_users(users)
Room.by_users(private_room.users)
          room = Room.by_users(private_room.users)
Room.private_rooms.
      select('rooms.*, COUNT(users_rooms.user_id)').
      joins(:users_rooms).
      where(users_rooms: { user_id: users }).
      group('rooms.id').
      having('COUNT(users_rooms.user_id) = ?', users.size)
Room.private_rooms.
      select('rooms.*, COUNT(users_rooms.user_id)').
      joins(:users_rooms).
      where(users_rooms: { user_id: users.ids }).
      group('rooms.id').
      having('COUNT(users_rooms.user_id) = ?', users.size)
users = private_room.users
private_room.users.size
private_room.users
c
member1.email
private_room.display_name_for(member1)
private_room.users.size
c
user.private_room_with(other_user) == private_room
user.private_room_with(other_user)
user.rooms
c
user.rooms
user_users_room
user.rooms
other_user.rooms
c
other_user.rooms
user.rooms.first.id
user.rooms
user.users_rooms
user_users_room
c
user_users_room
user
user.users_rooms
user.rooms
user.private_rooms
user
c
users_room.errors.messages
users_room.errors
users_room.save
c
users_room.save!
users_room.save
users_room.room.is_private
users_room.room
c
users_room.save
users_room
c
users_room.send(:set_status_and_role)
users_room.role
c
users_room_owner.role
c
UsersRoom::ROLES.include?(users_room_owner.role)
UsersRoom::ROLES.include?(plop.role)
UsersRoom::ROLES
UsersRoom::Roles
plop.role
plop = build(:users_room_owner)
c
plop
plop.status = :accepted
plop = build(:users_room_owner)
users_room_owner.valid?
plop.valid?
plop = build(:users_room_owner)
c
UsersRoom::STATUS.include?(plop.status)
UsersRoom::STATUS
UsersRoom::status
UsersRoom.status
plop = build(:users_room_owner)
users_room_owner.status
c
users_room.save
expect {users_room.save}.to be_valid
c
exit
users_room.save
users_room.create
users_room.room.is_private
c
is_private
self
c
